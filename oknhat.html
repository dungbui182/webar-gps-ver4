<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR GPS - C·∫ßu N·ªëi Hai B·ªù</title>
    <!-- A-Frame itself -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>

    <!-- Pure three.js code that the A-Frame components use for location-based AR -->
    <script type='text/javascript'
        src='https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/build/ar-threex-location-only.js'></script>

    <!-- AR.js A-Frame components -->
    <script type='text/javascript'
        src='https://raw.githack.com/AR-js-org/AR.js/3.4.5/aframe/build/aframe-ar.js'></script>
    <!-- A-Frame -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@6.1.0/dist/aframe-extras.controls.min.js"></script>

    <script>

        // üåâ X·ª≠ l√Ω xoay v√† ph√≥ng to b·∫±ng 2 ng√≥n tay
        AFRAME.registerComponent('gesture-handler', {
            schema: { enabled: { default: true } },
            init: function () {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);
                this.startDistance = null;
                this.startX = null;

                this.el.sceneEl.addEventListener("touchstart", (event) => {
                    if (event.touches.length === 2) {
                        this.startDistance = this.getDistance(event.touches);
                    } else if (event.touches.length === 1) {
                        this.startX = event.touches[0].clientX; // L∆∞u v·ªã tr√≠ X ban ƒë·∫ßu
                    }
                });

                this.el.sceneEl.addEventListener("touchmove", (event) => {
                    if (event.touches.length === 2) {
                        this.handleScale(event);
                    } else if (event.touches.length === 1) {
                        this.handleRotation(event);
                    }
                });
            },

            getDistance: function (touches) {
                let dx = touches[0].clientX - touches[1].clientX;
                let dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            },

            handleScale: function (event) {
                let newDistance = this.getDistance(event.touches);
                if (!this.startDistance) return;
                let scaleChange = newDistance / this.startDistance;
                let model = this.el;
                let scale = model.getAttribute("scale");
                model.setAttribute("scale", {
                    x: scale.x * scaleChange,
                    y: scale.y * scaleChange,
                    z: scale.z * scaleChange
                });
                this.startDistance = newDistance;
            },

            handleRotation: function (event) {
                let newX = event.touches[0].clientX;
                if (this.startX === null) return;

                let rotationChange = (newX - this.startX) * 0.5; // ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô xoay
                let model = this.el;
                let rotation = model.getAttribute("rotation");

                model.setAttribute("rotation", {
                    x: 0, // Kh√¥ng thay ƒë·ªïi tr·ª•c X
                    y: rotation.y + rotationChange, // Xoay quanh tr·ª•c Y
                    z: 0  // Kh√¥ng thay ƒë·ªïi tr·ª•c Z
                });

                this.startX = newX;
            }

        });

    </script>
</head>

<body>
    <!-- <a-scene vr-mode-ui="enabled: false" arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"> -->
    <a-scene vr-mode-ui="enabled: false" arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: true;">

        <!-- Th√™m √°nh s√°ng -->
        <a-light type="ambient" color="#ffffff" intensity="0.5"></a-light>
        <a-light type="directional" color="#ffffff" intensity="1.0" position="1 3 1"></a-light>
        <!-- Camera -->
        <a-camera gps-camera gpsMinDistance="5" rotation-reader></a-camera>

        <!-- C√¢y c·∫ßu hi·ªÉn th·ªã ngay -->
        <a-entity id="helix_bridge" gps-entity-place="latitude: 10.912037; longitude: 106.584806" position="0 0 0"
            scale="1 1 1" gltf-model="helix_bridge.glb" rotation="0 0 0" visible="true" gesture-handler>
        </a-entity>

    
    </a-scene>

    <div id="coords"
        style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; font-size: 14px;">
        üìç ƒêang x√°c ƒë·ªãnh v·ªã tr√≠...
    </div>

    <script>
        console.log({ THREE, AFRAME });
        // üéØ Theo d√µi v·ªã tr√≠ GPS
        navigator.geolocation.watchPosition(success, error, { enableHighAccuracy: true });

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // B√°n k√≠nh Tr√°i ƒê·∫•t (m√©t)
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Kho·∫£ng c√°ch t√≠nh b·∫±ng m√©t
        }

        function success(position) {
            let lat = position.coords.latitude;
            let lon = position.coords.longitude;
            let bridgeLat = 10.912037;
            let bridgeLon = 106.584806;
            let distance = calculateDistance(lat, lon, bridgeLat, bridgeLon).toFixed(2); // L√†m tr√≤n 2 s·ªë l·∫ª
            document.getElementById("coords").innerHTML = `üìç Lat: ${lat} <br> Lon: ${lon} <br> üî¢ Kho·∫£ng c√°ch: ${distance}m`;
        }


        function error() {
            console.log("‚ùå Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠.");
        }

        // function calculateDistance(lat1, lon1, lat2, lon2) {
        //     const R = 6371e3; // B√°n k√≠nh Tr√°i ƒê·∫•t (m√©t)
        //     const œÜ1 = lat1 * Math.PI / 180;
        //     const œÜ2 = lat2 * Math.PI / 180;
        //     const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
        //     const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

        //     const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
        //         Math.cos(œÜ1) * Math.cos(œÜ2) *
        //         Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
        //     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        //     return R * c; // Kho·∫£ng c√°ch t√≠nh b·∫±ng m√©t
        // }

        // let lastLat = null;
        // let lastLon = null;
        // let bridgeLat = 10.772957;
        // let bridgeLon = 106.708171;

        // navigator.geolocation.watchPosition((position) => {
        //     let lat = position.coords.latitude;
        //     let lon = position.coords.longitude;
        //     if (lastLat && lastLon && Math.abs(lat - lastLat) < 0.00001 && Math.abs(lon - lastLon) < 0.00001) {
        //         return; // B·ªè qua c·∫≠p nh·∫≠t n·∫øu di chuy·ªÉn qu√° nh·ªè
        //     }
        //     lastLat = lat;
        //     lastLon = lon;
        //     let distance = calculateDistance(lat, lon, bridgeLat, bridgeLon).toFixed(2);
        //     document.getElementById("coords").innerHTML = `üìç Lat: ${lat} <br> Lon: ${lon} <br> üî¢ Kho·∫£ng c√°ch: ${distance}m`;
        //     // ƒê·∫∑t l·∫°i c·∫ßu v·ªÅ v·ªã tr√≠ c·ªë ƒë·ªãnh
        //     let bridge = document.querySelector("#helix_bridge");
        //     if (bridge) {
        //         bridge.setAttribute("gps-entity-place", `latitude: ${bridgeLat}; longitude: ${bridgeLon}`);
        //         bridge.setAttribute("position", "0 0 0");
        //     }
        // }, error, { enableHighAccuracy: true });

    </script>
</body>

</html>